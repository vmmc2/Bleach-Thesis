\chapter{Evaluation} \label{cap:Resultados}

\begin{displayquote}
    \begin{center}
        \textit{``There is no pain as long as I keep my eyes on the balance scale.''}
    \end{center}
\end{displayquote}

\begin{flushright}
   \textit{-- TITE KUBO}
\end{flushright}

\section{Introduction}

\section{Bleach's Test Suite}
Mostrar como funciona a suite de testes do interpretador implementado, onde cada nó da AST é testado individualmente, quando possível, e em conjunto com outros tipos de nó da AST.

\section{Implementing Famous Algorithms and Data Structures in Bleach}
A ideia seria mostrar a expressividade da linguagem por meio da implementação de algoritmos famosos.
\begin{itemize}
    \item Stack
        \centering
        \begin{lstlisting}
class Node{
  method init(value){
    self.value = value;
    self.next = nil;
  }

  method str(){
    return self.value;
  }
}

class Stack{
  method init(){
    self.root = nil;
    self.length = 0;
  }

  method empty(){
    return self.length == 0 ? true : false;
  }

  method size(){
    return self.length;
  }

  method push(value){
    let newNode = Node(value);
    if(self.root == nil){
      self.root = newNode;
    }else{
      newNode.next = self.root;
      self.root = newNode;
    }

    self.length = self.length + 1;

    return nil;
  }

  method pop(){
    if(self.root == nil){
      return "The stack is empty.";
    }else{
      let poppedValue = self.root;
      self.root = self.root.next;

      self.length = self.length - 1;

      return poppedValue;
    }
  }

  method str(){
    let stackAsString = "";
    let curr = self.root;
    while(curr != nil){
      stackAsString = stackAsString + (curr.value + " -> ");
      curr = curr.next;
    }
    stackAsString = stackAsString + " nil";

    return stackAsString;
  }

  method top(){
    if(self.root == nil){
      return "The stack is empty.";
    }else{
      return self.root;
    }
  }
}
        \end{lstlisting}



    \item Queue
        \centering
        \begin{lstlisting}
class Node{
  method init(value){
    self.value = value;
    self.next = nil;
  }

  method str(){
    return self.value;
  }
}

class Queue{
  method init(){
    self.left = nil;
    self.right = nil;
    self.length = 0;
  }

  method empty(){
    return self.length == 0 ? true : false;
  }

  method size(){
    return self.length;
  }

  method front(){
    if(self.left == nil){
      return "The queue is empty.";
    }else{
      return self.left;
    }
  }

  method back(){
    if(self.right == nil){
      return "The queue is empty.";
    }else{
      return self.right;
    }
  }

  method push(value){
    if(self.length == 0){
      let newNode = Node(value);
      self.left = newNode;
      self.right = self.left;
    }else{
      let newNode = Node(value);
      self.right.next = newNode;
      self.right = newNode;
    }

    self.length = self.length + 1;

    return;
  }

  method pop(){
    if(self.length == 0){ // Queue is empty.
      return "The queue is empty.";
    }elif(self.length == 1){ // Queue is not empty and has only one element.
      let poppedValue = self.left.value;

      self.left = nil;
      self.right = nil;

      self.length = self.length - 1;

      return poppedValue;
    }else{ // Queue is not empty and has more than one element.
      let poppedValue = self.left.value;

      self.left = self.left.next;
      self.length = self.length - 1;

      return poppedValue;
    }
  }

  method str(){
    let queueAsString = "front -> ";
    let curr = self.left;
    while(curr != nil){
      if(curr != nil and curr.next != nil){
        queueAsString = queueAsString + (curr.value + " -> ");
      }else{
        queueAsString = queueAsString + curr.value;
      }
      curr = curr.next;
    }
    queueAsString = queueAsString + " <- back";

    return queueAsString;
  }
}
        \end{lstlisting}


    \item Insertion Sort
        \centering
        \begin{lstlisting}
/*
Code that implements the Insertion Sort algorithm.
Assumes it is a list where every value is of type 'num'.
*/

function insertionSort(l){
  let n = l.size();

  for(let i = 0; i < n; i = i + 1){
    let curr = i;
    while(curr > 0 and l.getAt(curr) < l.getAt(curr - 1)){
      let temp = l.getAt(curr);
      l.setAt(curr, l.getAt(curr - 1));
      l.setAt(curr - 1, temp);
      curr = curr - 1;
    }
  }

  return;
}
        \end{lstlisting}
    \item Merge Sort
    \item Quick Sort
    \item Binary Search
        \centering
        \begin{lstlisting}
function binarySearch(list, target){
  let left = 0;
  let right = list.size() - 1;

  while(left <= right){
    let mid = std::math::floor((left + right) / 2);
    if(list.getAt(mid) == target){
      return mid;
    }elif(list.getAt(mid) > target){
      right = mid - 1;
    }else{
      left = mid + 1;
    }
  }

  return -1; // Target value not present inside the list.
}
        \end{lstlisting}
    \item Binary Search Tree (BST)
    \item Binary Heap
    \item Depth First Search (DFS)
        \centering
        \begin{lstlisting}
function dfs(source, adjacencyList, visitingOrder, visited){
  visited.setAt(source, true);
  visitingOrder.append(source);

  for(let i = 0; i < adjacencyList.getAt(source).size(); i = i + 1){
    let neighbor = adjacencyList.getAt(source).getAt(i);
    if(!visited.getAt(neighbor)){
      dfs(neighbor, adjacencyList, visitingOrder, visited);
    }
  }

  return;
}
        \end{lstlisting}
    \item Breadth First Search (BFS)
        \centering
        \begin{lstlisting}
function bfs(source, adjacencyList, visited, distance){
  visited.setAt(source, true);
  distance.setAt(source, 0);

  let queue = Queue();
  queue.push(source);

  while(!queue.empty()){
    let currNode = queue.pop();

    for(let i = 0; i < adjacencyList.getAt(currNode).size(); i = i + 1){
      let neighbor = adjacencyList.getAt(currNode).getAt(i);

      if(!visited.getAt(neighbor)){
        visited.setAt(neighbor, true);
        distance.setAt(neighbor, 1 + distance.getAt(currNode));
        queue.push(neighbor);
      }
    }
  }

  return;
}
        \end{lstlisting}
    \item Dijkstra's Shortest Path Algorithm
\end{itemize}

\section{Comparing Bleach with ChocoPy, Cool and MiniJava}
Seria apenas uma tabela comparando as features existentes e não existentes em cada uma das linguagens.

\section{Evaluating Bleach with the "The Computer Languages Benchmark Game"}

\section{Survey Among Professors, Instructors and Teaching Assistants}
Não tenho muita certeza se temos tempo suficiente para preparar uma pesquisa, colher resultados e analisá-los de forma adequada a fim de chegar em uma conclusão. Dito isso, estou inclinado a retirar essa seção.