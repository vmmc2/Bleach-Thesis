\chapter{Evaluation} \label{cap:Resultados}

\begin{displayquote}
    \begin{center}
        \textit{``There is no pain as long as I keep my eyes on the balance scale.''}
    \end{center}
\end{displayquote}

\begin{flushright}
   \textit{-- TITE KUBO}
\end{flushright}

\section{Introduction}
This chapter is dedicated to present to the reader a series of different approaches that were taken in order to test the Bleach programming language and the Tree-Walk Interpreter implemented for it from different perspectives. Regarding these perspectives, the following approaches were taken:
\begin{itemize}
    \item \textbf{Test Suite:} For the reader that is not familiar with this concept: A Test Suite is a carefully tailored collection of test cases and test scripts implemented in order to verify that a software program or a specific module of a program is behaving as expected.
    
    \item \textbf{Implementation of famous Algorithms and Data Structures:} As a way to better demonstrate Bleach's expressiveness and prowess, this section is dedicated to present to the reader implementation of famous Algorithms and Data Structures commonly taught in an undergraduate Computer Science degree.
    
    \item \textbf{Comparison of Bleach with ChocoPy, Cool and MiniJava:} Regarding comparison with its predecessors, this section is dedicated to compare Bleach with them in terms of language features.
    
    \item \textbf{Evaluation using the "The Computer Languages Benchmark Game":} Last but not least, in this section the mentioned framework is used to better illustrate the features of the language proposed in this document.
\end{itemize}


\section{Bleach's Test Suite}
As mentioned above, one of the different ways to evaluate Bleach was through the creation of a test suite that verifies the correctness of the Tree-Walk Interpreter implementation. In this particular scenario, this test suite is composed of both test cases and a test script responsible for executing the test cases automatically.

Diving deeper in how the test suite was implemented, it is composed of 44 test cases and a test script that executes such test in an automated manner.

These 44 test cases work as unit and integration tests divided into 3 groups (tests responsible for Expression nodes, tests responsible for Statement nodes and tests responsible for some of the Bleach Native Functions). All types of AST nodes previously presented in Table~\ref{tab:AST_nodes} are covered. Moreover, from these 44 test cases are 2 of them that cover the functioning the native functions from the following namespaces: \texttt{std::math} and \texttt{std::utils}.

Each test case is composed by a Bleach file (\texttt{.bch} extension) representing the Bleach program that will be executed by the interpreter, a file with the extension 
 \texttt{.bch.expected}, representing the expected output for that corresponding \texttt{.bch} file and, finally, a corresponding \texttt{.bch.log} file that represents the actual output generated by the execution of such \texttt{.bch} file. Finally, the difference between the \texttt{.bch.expected} and the \texttt{.bch.log} is computed. If there are no differences, then it means that the particular test case passed. Otherwise, it did not.

 All this process is automated by a shell script called \texttt{bleach\_test\_pipeline.sh} that automatically executes each Bleach program and compares its expected output file with the produced output file. In the end, this script provides a simple metric displaying how many of the test cases have passed from the total number and it also shows which test cases did not pass.

 More detailed information about how to execute Bleach's test suite can be found at Bleach's official GitHub repository \cite{bleach_lang_git_repo}.


\section{Implementing Famous Algorithms and Data Structures in Bleach}
As stated in the first section of this chapter, here the main goal is to show the expressiveness and prowess of Bleach by showing that it is possible to implement common algorithms and data structures that are usually taught in an undergraduate "Introduction to Algorithms" course in a Computer Engineering/Computer Science degree.

\begin{itemize}
    \item Stack
        \begin{lstlisting}
class Node{
  method init(value){
    self.value = value;
    self.next = nil;
  }

  method str(){
    return self.value;
  }
}

class Stack{
  method init(){
    self.root = nil;
    self.length = 0;
  }

  method empty(){
    return self.length == 0 ? true : false;
  }

  method size(){
    return self.length;
  }

  method push(value){
    let newNode = Node(value);
    if(self.root == nil){
      self.root = newNode;
    }else{
      newNode.next = self.root;
      self.root = newNode;
    }

    self.length = self.length + 1;

    return nil;
  }

  method pop(){
    if(self.root == nil){
      return "The stack is empty.";
    }else{
      let poppedValue = self.root;
      self.root = self.root.next;

      self.length = self.length - 1;

      return poppedValue;
    }
  }

  method str(){
    let stackAsString = "";
    let curr = self.root;
    while(curr != nil){
      stackAsString = stackAsString + (curr.value + " -> ");
      curr = curr.next;
    }
    stackAsString = stackAsString + " nil";

    return stackAsString;
  }

  method top(){
    if(self.root == nil){
      return "The stack is empty.";
    }else{
      return self.root;
    }
  }
}
        \end{lstlisting}


    \item Queue
        \begin{lstlisting}
class Node{
  method init(value){
    self.value = value;
    self.next = nil;
  }

  method str(){
    return self.value;
  }
}

class Queue{
  method init(){
    self.left = nil;
    self.right = nil;
    self.length = 0;
  }

  method empty(){
    return self.length == 0 ? true : false;
  }

  method size(){
    return self.length;
  }

  method front(){
    if(self.left == nil){
      return "The queue is empty.";
    }else{
      return self.left;
    }
  }

  method back(){
    if(self.right == nil){
      return "The queue is empty.";
    }else{
      return self.right;
    }
  }

  method push(value){
    if(self.length == 0){
      let newNode = Node(value);
      self.left = newNode;
      self.right = self.left;
    }else{
      let newNode = Node(value);
      self.right.next = newNode;
      self.right = newNode;
    }

    self.length = self.length + 1;

    return;
  }

  method pop(){
    if(self.length == 0){ // Queue is empty.
      return "The queue is empty.";
    }elif(self.length == 1){ // Queue is not empty and has only one element.
      let poppedValue = self.left.value;

      self.left = nil;
      self.right = nil;

      self.length = self.length - 1;

      return poppedValue;
    }else{ // Queue is not empty and has more than one element.
      let poppedValue = self.left.value;

      self.left = self.left.next;
      self.length = self.length - 1;

      return poppedValue;
    }
  }

  method str(){
    let queueAsString = "front -> ";
    let curr = self.left;
    while(curr != nil){
      if(curr != nil and curr.next != nil){
        queueAsString = queueAsString + (curr.value + " -> ");
      }else{
        queueAsString = queueAsString + curr.value;
      }
      curr = curr.next;
    }
    queueAsString = queueAsString + " <- back";

    return queueAsString;
  }
}
        \end{lstlisting}


    \item Insertion Sort
        \begin{lstlisting}
/*
Code that implements the Insertion Sort algorithm.
Assumes it is a list where every value is of type 'num'.
*/

function insertionSort(l){
  let n = l.size();

  for(let i = 0; i < n; i = i + 1){
    let curr = i;
    while(curr > 0 and l.getAt(curr) < l.getAt(curr - 1)){
      let temp = l.getAt(curr);
      l.setAt(curr, l.getAt(curr - 1));
      l.setAt(curr - 1, temp);
      curr = curr - 1;
    }
  }

  return;
}
        \end{lstlisting}
    \item Merge Sort
    \item Quick Sort
    \item Binary Search
        \begin{lstlisting}
function binarySearch(list, target){
  let left = 0;
  let right = list.size() - 1;

  while(left <= right){
    let mid = std::math::floor((left + right) / 2);
    if(list.getAt(mid) == target){
      return mid;
    }elif(list.getAt(mid) > target){
      right = mid - 1;
    }else{
      left = mid + 1;
    }
  }

  return -1; // Target value not present inside the list.
}
        \end{lstlisting}
    \item Binary Search Tree (BST)
    \item Binary Heap
    \item Depth First Search (DFS)
        \begin{lstlisting}
function dfs(source, adjacencyList, visitingOrder, visited){
  visited.setAt(source, true);
  visitingOrder.append(source);

  for(let i = 0; i < adjacencyList.getAt(source).size(); i = i + 1){
    let neighbor = adjacencyList.getAt(source).getAt(i);
    if(!visited.getAt(neighbor)){
      dfs(neighbor, adjacencyList, visitingOrder, visited);
    }
  }

  return;
}
        \end{lstlisting}
    \item Breadth First Search (BFS)
        \begin{lstlisting}
function bfs(source, adjacencyList, visited, distance){
  visited.setAt(source, true);
  distance.setAt(source, 0);

  let queue = Queue();
  queue.push(source);

  while(!queue.empty()){
    let currNode = queue.pop();

    for(let i = 0; i < adjacencyList.getAt(currNode).size(); i = i + 1){
      let neighbor = adjacencyList.getAt(currNode).getAt(i);

      if(!visited.getAt(neighbor)){
        visited.setAt(neighbor, true);
        distance.setAt(neighbor, 1 + distance.getAt(currNode));
        queue.push(neighbor);
      }
    }
  }

  return;
}
        \end{lstlisting}
    \item Dijkstra's Shortest Path Algorithm
\end{itemize}

\section{Comparing Bleach with ChocoPy, Cool and MiniJava}
In this section, a comparison between Bleach, ChocoPy, Cool and MiniJava is made in terms of the features available in each of these programming languages.

The mentioned comparison is illustrated below:

\begin{table}[h!]
    \centering
    \begin{tabular}{|p{3.2cm}|p{3cm}|p{3cm}|p{3cm}|p{3cm}|p{3cm}|}
        \hline
        \textbf{Feature} & \textbf{Bleach} & \textbf{ChocoPy} & \textbf{Cool} & \textbf{MiniJava} \\  % First row: header
        \hline
        \textbf{Type System} & Dynamically-Typed & Statically-Typed & Statically-Typed & Statically-Typed \\  % Data rows
        \hline
        \textbf{Built-In Types} & \texttt{bool}, \texttt{nil}, \texttt{num}, \newline \texttt{list}, \texttt{str} & \texttt{int}, \texttt{bool}, \texttt{None}, \texttt{list}, \texttt{str} & \texttt{Int}, \texttt{Bool}, \texttt{String} & \texttt{int}, \texttt{int[ ]} \texttt{boolean}, \texttt{void} \\
        \hline
        \textbf{Arithmetical Operators} & \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%} & \texttt{+}, \texttt{-}, \texttt{*}, \texttt{//}, \texttt{\%} & \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} & \texttt{+}, \texttt{-}, \texttt{*} \\
        \hline
        \textbf{Comparison Operators} & \texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=} & \texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=} & \texttt{<}, \texttt{<=} & \texttt{<} \\
        \hline
        \textbf{Equality Operators} & \texttt{==}, \texttt{!=} & \texttt{==}, \texttt{!=}, \texttt{is} & \texttt{=} & No support \\
        \hline
        \textbf{Logical Operators} & \texttt{and}, \texttt{or}, \texttt{!} & \texttt{and}, \texttt{or}, \texttt{not} & \texttt{not} & \texttt{\&\&}, \texttt{!} \\
        \hline
        \textbf{Assignment Operator} & \texttt{=} & \texttt{=} & \texttt{<-} & \texttt{=} \\
        \hline
        \textbf{Ternary Operator Support} & Yes & Yes & No & No \\
        \hline
        \textbf{If Statement Support} & \texttt{if}, \texttt{elif}, \texttt{else} & \texttt{if}, \texttt{elif}, \texttt{else} & \texttt{if}, \texttt{else} & \texttt{if}, \texttt{else} \\
        \hline
        \textbf{Loops Support} & \texttt{for}, \texttt{do-while}, \texttt{while} & \texttt{while}, \texttt{for in} (only in lists and strings) & \texttt{while} & \texttt{while} \\
        \hline
        \textbf{Break/Continue Statements Support} & Yes, Yes & No, No & No, No & No, No \\
        \hline
        \textbf{Function Declaration Support} & Yes (with the \texttt{function} keyword) & Yes (with the \texttt{def} keyword) & Yes (only method declaration within classes) & Yes (only method declaration within classes) \\
        \hline
        \textbf{Anonymous Function Support} & Yes (with the \texttt{lambda} keyword) & No & No & No \\
        \hline
        \textbf{Comments} & Single-line (\texttt{//}) and Multi-line (\texttt{/**/}) & Single-Line (\texttt{\#}) & Single-line (\texttt{---}) and Multi-line (\texttt{**}) & Single-line (\texttt{//}) and Multi-line (\texttt{/**/}) \\
        \hline
        \textbf{Language Paradigm} & Object-Oriented and Interpreted & Object-Oriented and Compiled & Object-Oriented and Compiled & Object-Oriented and Compiled \\
        \hline
        \textbf{Inheritance} & Single & Single & Single & Single \\
        \hline
    \end{tabular}
    \caption{Comparison between Bleach, ChocoPy, Cool and MiniJava.}
    \label{tab:example5x5}
\end{table}


\section{Evaluating Bleach with the "The Computer Languages Benchmark Game"}

\section{Survey Among Professors, Instructors and Teaching Assistants}
Não tenho muita certeza se temos tempo suficiente para preparar uma pesquisa, colher resultados e analisá-los de forma adequada a fim de chegar em uma conclusão. Dito isso, estou inclinado a retirar essa seção.