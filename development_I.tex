\chapter{Context and Purpose} \label{cap:metodologia}

\begin{displayquote}
    \begin{center}
        \textit{``I wonder if I can keep up with... the speed of a world you're not in.''}
    \end{center}
\end{displayquote}

\begin{flushright}
   \textit{-- NORIAKI KUBO}
\end{flushright}

\section{Introduction}
This chapter is dedicated to provide the historical context on how the way of teaching undergraduate Compilers courses evolved since the 70s, as well as a brief overview of surveys that demonstrate the positive impact that more practice-oriented approaches brings to students. Such factors are what motivated the creation of the Bleach programming language. Furthermore, a subsection dedicated to recall the purpose of Bleach is provided. Then, an analysis about how Bleach distinguishes itself from other proposed programming languages that also aim to be used in Compiler courses is presented. In the end, the chapter provides a detailed description about the context Bleach is inserted in, which includes: the target audience, educational environment, typical use cases and the educational benefits provided by it.

\section{Historical Evolution of Compilers Courses}
Looking back at the history of compiler construction \cite{wikipedia_compiler_construction} and the history of programming languages \cite{wikipedia_programming_languages}, it can be said that the way of teaching an undergraduate Compilers courses evolved as follows.

During the 1970s, undergraduate Compilers courses used to have a heavy focus on the theoretical aspects of the field, such as formal languages, automata theory, lexing techniques and parsing techniques. During that period, access to computational resources were still scarce, even in an academic environment. However, students were still able to implement toy compilers in different tastes of Assembly or in an early high-level language like Fortran \cite{fortran_official_website}. Still, the pillars of this course emphasized a deep understanding of the theoretical and formal aspects mentioned above.

In the 1980s, even though the focus of these courses remained rooted in theoretical aspects (lexical analysis, syntax analysis and the fundamental of code generation and optimization), a gradual shift from theory to practice started to happen. Thanks to the spread of languages like C \cite{kernighan1988c}, C++ \cite{strousrup2000c++} and Pascal \cite{wirth1971programming}, more practical implementations of compilers were allowed to be made. Therefore, courses started to add more practical projects. In such projects, students were usually asked to write a compiler (or parts of one) in these new languages. Last, but not least, the rise of UNIX \cite{ritchie1978unix}, Lex \cite{lesk1975lex} and Yacc \cite{johnson1975yacc} allowed students to implement components of a compiler with more ease.

In the 90s, such courses had already become more oriented to hands-on experience thanks to the improvements achieved in the previous decade. The birth of languages like Java \cite{java_17_official_specification} and the increase in computational power of personal computers allowed students to tackle more complex compiler projects. Courses started to assign to students more complicated tasks like the implementation of entire compilers for small languages or significant compiler components, such as code generators and optimizers. Moreover, the textbook \cite{aho1986compilers}, popularly known as "The Dragon Book", became the standard reference in this field.

In the 00s, this trend of giving more focus to the practical experience went on, with a focus on real-world applications and the use of modern programming languages. Furthermore, courses began to add more advanced topics to their syllabus, such as just-in-time compilation, garbage collection, and runtime environments. It is safe to say that the way of teaching Compilers became more holistic, covering not just compiler theory and implementation but also language design and performance optimization. During this period, Alfred Aho published \cite{aho2008teaching}, an article in which he reflects on how the way of teaching undergraduate Compilers courses has evolved through the years and also how he changed his way of teaching such course. According to him, it is still possible to teach it in a way that provides educational benefits and satisfaction to the students. The latest approach adopted by him consisted on presenting the basics of the most important topics (lexical analysis, syntax analysis, semantic analysis, intermediate code generation, runtime environments, resource management and target code generation). At the same time, Aho asked his students to implement a compiler and provided the specifications of the source and target languages for the compiler they were implementing. He also noticed that the students were not excited about implementing someone else's language. Thus, he took a bold move and assigned his students the task of working in smalls team to define their own
language and then build a compiler for it. Such approach, according to him, made the students much more engaged and excited.

Finally, in the 2010s and 2020s, the teaching of this course continued the trend of emphasis on balancing theory and practice. Such factor influenced the way Compilers courses were taught, as professors and instructors began to integrate more diverse and flexible learning materials, including video lectures, interactive simulations, and online coding platforms. Also, the COVID-19 pandemic played an important role in this change, since it forced educators to rethink how compilers could be taught in a remote manner, which led to rise of new assisting tools like virtual laboratories, collaborative coding environments and online assessments. Consequently, such courses became more modular, allowing students to learn at their own pace and apply their knowledge in a way that felt meaningful to them.

\section{Reports on Practical Ways of Teaching Compilers Courses}
In this section, a few reports that discuss different approach to teach an undergraduate Compilers course are presented, along with their main findings.

In 2015, Lasseter \cite{lasseter2015interpreter} proposed a new strategy to present the fundamental concepts of an undergraduate Compiler Construction course. The suggested approach defends that the concept of an Interpreter serves as an effective conceptual framework that can be used to educate students about the later stages of the compilation pipeline, specially the semantic analysis and code generation phases. As reported by the author, this way of teaching is useful in the way that it not only unifies the major theoretical concepts of this undergraduate course, but is also helpful when it comes to the implementation of semester-long compiler construction project. At Hobart \& William Smith Colleges, the university where Lasseter works, the undergraduate Compiler Construction course is a one-semester, upper-division elective, offered every other year. The course addresses both software engineering aspects as well as the major concepts of a traditional Compilers course (lexing, parsing, semantic analysis and code generation). Moreover, it already adopts a more practice-oriented approach where every student must present a working compiler by the end of the 15-week semester. When it comes to the course project itself, Lasseter opted to use the Tiger programming language \cite{appel1998tiger}, originally developed by Andrew Appel for his project-oriented "Modern Compiler Implementation" suite of C, ML and Java textbooks \cite{appel1997modernCompilerImplementationC}, \cite{appel2002modernCompilerImplementationJava}, \cite{appel2004modernCompilerImplementationML}. During the years in which the author was responsible for this course, he noticed a worrying pattern: Even though the students did well in the first stages of compilation (lexing and parsing), the vast majority of them started to struggle with the semantic analysis stage. According to the students, the combination of the underlying concepts of type checking, the details of the famous visitor pattern when traversing an AST and the interaction between this design pattern and a real-world semantic analysis implementation is just too overwhelming. Given this scenario, Lasseter chose to schedule individual meetings with this students where he introduced the idea of a language's interpreter as a touchstone to better explain the last two stages of the compilation pipeline. His investigation led to the fact that such approach proved to be the to be most uniformly effective among the students with whom he discussed. In light of this discovery, professor Lasseter reorganized his lectures introducing these specific compiler phases to include the interpreter structure as a reference point. Finally, he came to the conclusion that adding lectures that presented the concepts behind the interpreter framework resulted on better understanding of the students when it came down to the semantic analysis and code generation phases of the compilation process, indicating that the idea of an interpreter has a substantial educational value in this field.

In 2016, Kundra et al. \cite{kundra2016experience} proposed a novel approach called "Case-based and Project-based Learning" to teach a Compilers Design course to third year students of a Delhi University (India) college. The responsibles for implementing such methodology based themselves in the definition of what is Traditional Learning, presented in \cite{altman2010workplace}, and used the definition and core ideas of Case-based Learning, presented in \cite{golich2000abcs}, in order to propose their own method. According to the authors, this proposed method combines 4 different pedagogical models, which makes this approach unique and effective: Didactic Teaching \cite{altman2010workplace}, Problem-Based Learning \cite{hmelo2004problem}, Cognitive Apprenticeship Model \cite{dennen2008cognitive} and Project-Based Learning \cite{thomas2000review}. To implement it, they divided one core project of this class into several sub-projects with the goal of improving the practical experience of the students when it came down to the task of designing a compiler. To evaluate the effectiveness of this approach, students were asked to complete a survey that grasped on their perceptions about the upsides of such method. Such survey was analyzed using the following statistical tools: frequency estimation and chi square test of association. According to the paper, the results showed that the proposed approach indeed had a positive impact on students since it enhanced their learning, critical thinking, engagement, communication skills and team work. In the end, the authors came to the conclusion that the outcome of the survey analysis showed that both Case-based and Project-based learning are suitable for teaching concepts of compilers implementation.

In 2021, Robert Nystrom, a software engineer that works at Google on the Dart language, published the "Crafting Interpreters" book \cite{nystrom2021crafting}: An extensive guide about not only implementing two different types of interpreters for Lox, a full-featured programming language designed by the author, but also a walkthrough that guides the readers on how they can design their own programming language. The book assumes that it is the reader's first contact with this field. Therefore, it covers each concept needed in an approachable style while also providing every line of code needed to implement the two types of interpreters covered. As the author himself admits in the first chapter of the book, "Crafting Interpreters" is not meant to be as rigorous as other references, such as \cite{aho1986compilers} or \cite{cooper2022engineering} when it comes to the theoretical foundation of programming languages. Instead, as suggested earlier, its purpose is to be lighter in theory, while still introducing the history and core concepts of programming languages implementation. Moreover, the author stands by the point of view that the best way of learning a new subject is by practicing and experimenting. He even says that his goal is that every reader finish his book with a solid intuition about how real programming languages work. The book also aims that the reader will feel more comfortable when reading more advanced and theoretical books later on, such as \cite{aho1986compilers}, \cite{cooper2022engineering} or \cite{muchnick1997advanced}. It is important to keep in mind that the book's focus is on building interpreters, which are simpler and more accessible to understand when compared to compilers. Furthermore, this way of teaching allows the students to have a better comprehension of vital concepts previously mentioned, like lexing, parsing, abstract syntax trees, semantic analysis and runtime execution without the daunting complexity of optimization and code generation phases that most compilers require. This approach brings a lot of benefits for students and professors. With respect to the students, they are usually able to build a deeper and stronger foundation about how programming languages work since the project-based nature of the book makes them apply what they learn immediately. This solid foundation is, without a doubt, of great use to those who wish to delve deeper into the field. As for the professors, the engaging writing style of the book tends to keep students engaged and motivated during the whole duration of the course, which leads to a better retention and a more rewarding learning experience. Last but not least, it is important to highlight the fact that the "Crafting Interpreters" book is increasingly gaining more popularity and recognition due to its excellence when it comes to convey the subject of study. Its purchase page on Amazon \cite{nystrom_crafting_interpreters_amazon} is full of reviews praising its quality. On top of that, searching for the keywords "crafting interpreters" \cite{crafting_interpreters_repositories_github} in GitHub shows that there are more than 2600 public repositories implementing the Lox language presented in the book, which is also a testimonial of the popularity and quality of such material.

\section{Existing Toy Programming Languages}

Before taking a deep dive in what makes Bleach an actual and viable option to be used in a classroom environment, it is important to mention that there are several programming languages created with the purpose of being a supplementary tool for teaching undergraduate Compilers courses that have opted for a more practice-oriented procedure.

In this section, some of the most popular programming languages designed with this motivation are discussed in chronological order. The intention with this is to provide information about their origin, historical context and features.

\begin{itemize}
    \item \textbf{COOL (Classroom Object-Oriented Language):} This is a object-oriented and statically-typed programming language \cite{aiken1996cool} created in the 90s by Alexander Aiken and his colleagues at the Stanford University. It was designed with the intention to be used as a tool in an educational setting in universities. Even though COOL is simple and small, it has an interesting variety of features besides the ones mentioned above, such as: basic class types (Bool, Int, IO, Object and String), automatic garbage collection and many others that can be found at "The COOL Reference Manual" \cite{cool_reference_manual}.
    
    According to Aiken, a compiler project is normally the most complex software project that most undergraduate students will complete. Therefore, the use of a full-featured programming language (any language that has a substantial number of users, like C, C++, Pascal, etc) does not fit into the scope of such project. In practice, the usual approach was to select a subset of these popular languages and ask the students to implement them. However, according to Aiken, this method is too demanding for the teaching staff, since several steps must be taken after choosing a language for a Compilers course project. For example: a detailed specification of the prject itself must be written, any supporting software that might be used must be developed, tested and documented beforehand. Finally, the project itself must also be implemented by the teaching staff \textit{a priori} since, according to Aiken, such effort is required to guarantee that the project is complete, consistent and tractable.
    
    It was with all the efforts mentioned above to build a framework for a compiler project in mind that Aiken created COOL. Ultimately, it is worth mentioning that COOL is not only a programming language, but rather a freely available and portable compiler project. COOL has being distributed since its creation with the goal of helping professors from other institutions to leverage from the efforts of the project developers and the many students who have written COOL compilers in order to structure their own Compilers courses following their own tastes. COOL has been adopted at several relevant institutions, such as University of California, Berkeley \cite{aiken1996cool} (where it was first introduced), Stanford University \cite{stanford_cs143_compilers_course_page}, University of Illinois Urbana-Champaign \cite{university_of_illinois_urbana_champaign_compilers_course_page} and University of Michigan \cite{university_of_michigan_compiler_construction_course_page}.
    
    \item \textbf{MiniJava:} This programming language \cite{cambridge_minijava_project} is a subset, as its name suggests, of the Java programming language. MiniJava was created by Andrew Appel and Jens Palsberg during the 90s and was first presented as part of \cite{appel2002modernCompilerImplementationJava}. This subset of Java contains its most essential features, such as: classes, attributes/fields, methods, logical control structures (if-else) and loop control structures (while). However, since it was tailored for an educational environment, it doesn't contain Java's more advanced features, like: exceptions, generics, inheritance, interfaces and lambda functions. More details about which features MiniJava exactly has can be found at \cite{cambridge_minijava_project} and \cite{cambridge_minijava_grammar}.
        
    Its purpose is to be used as a teaching tool in Compilers courses. Since it is a subset, as previously mentioned, it allows the students to focus on the fundamental concepts of this subject without overwhelming them with the complexities of a full-fledged programming language like Java.
    A sign of its success is that MiniJava has been adopted in several prestigious universities worldwide as part of their computer science curriculum, particularly in courses related to compiler construction and programming language implementation, such as University of Washington \cite{university_of_washington_cs_compiler_construction_course_page_2024}, University of California, Los Angeles \cite{ucla_cs_compiler_construction_course_page_fall_2012}, among others, like the Loyola University of Chicago \cite{loyola_university_of_chicago_cs_compiler_construction_course_page_fall_2018}.     
    
    \item \textbf{C* (C Star):} The C* (C Star) programming language \cite{kirsch2017selfie} is a programming language created in 2017 by Christoph M. Kirsch as a component of the Selfie Open-Source Software Project \cite{selfie_official_website} \cite{selfie_official_repo_github}.

    According to Kirsch, the creation of C*, as well as the Selfie project as a whole, was inspired by seminal works made in different fields of Computer Science, such as: Algorithms \cite{knuth2011art} \cite{wirth1976algorithms}, Compilers \cite{wirth1996compiler}, Computer Architecture \cite{hennessy2011computer}, Operating Systems \cite{liedtke1996toward}, Programming Languages \cite{kernighan1988c} \cite{richards2009bcpl}, Systems Engineering \cite{dijkstra1968structure} \cite{goldberg1983smalltalk} \cite{nisan2005elements} \cite{sussman1996structure} and Theory of Computation \cite{sipser1996introduction}. In addition, it was motivated by the challenge of teaching the basics of this field to larger audiences that are not specifically majoring in Computer Science.

    Regarding adoption of C*, the language has been adopted by the University of Salzburg, in Austria, \cite{selfie_official_website}, and by the Czech Technical University (CTU), in Czech Republic \cite{cvut_compiler_construction_course_page}.

    C* has support for 5 different types of statements (assignment, if-then-else statement, while loop, function call, return). Related to this, the language also implements the following native built-in functions: \texttt{exit}, \texttt{malloc}, \texttt{open}, \texttt{read} and \texttt{write} (it is important to notice the absence of \texttt{close} and \texttt{free}). Regarding keywords, C* has just 6: \texttt{int}, \texttt{while}, \texttt{if}, \texttt{else}, \texttt{return} and \texttt{void}. Talking about functions, C* allows them to have parameters, local variables and a return value. With respect to operators, C* has support to the most common arithmetic (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, \texttt{\%}) and comparison (\texttt{==}, \texttt{!=}, \texttt{>}, \texttt{>=}, \texttt{<}, \texttt{<=}) operators. However, it does not support bit-wise nor boolean operators. There are just 2 data types present in C*: signed integer (\texttt{int}) and pointer to signed integer (\texttt{int*}). It's worth mentioning that C* has support for integer, character and string literal however. Finally, when it comes to the access of dynamically-allocated memory, the only way of doing so is through the use of the dereferencing operator (\texttt{*}).
    
    \item \textbf{ChocoPy:} ChocoPy is a programming language created in 2019 and first presented at Padhye et al. \cite{padhye2019chocopy} with the goal of being used as a teaching tool in an undergraduate course on compilers and programming languages implementation. It is a subset of Python 3.6 that uses static type annotations in order to ensure compile-time type-safety. The project stands out due to its complete specification, which uses a formal grammar, typing rules and operational semantics as described in \cite{padhye2019chocopy}. More technical information about ChocoPy can be found at ChocoPy's official website \cite{chocopy_official_website}.

    According to the authors of \cite{padhye2019chocopy}, the purpose of creating ChocoPy was based on the following 5 major reasons:
    \begin{itemize}
        \item \textbf{Familiarity:} The staff behind the project wanted to develop a language that was a subset of a widely used programming language, hence, prioritizing the familiarity of the students with it. With this reasoning in mind, Python \cite{python_language} was chosen.
        \item \textbf{Expressiveness:} The professionals responsible for ChocoPy wanted to create a language that allowed students to write non-trivial programs in it. Particularly, an Object-Oriented paradigm with enough complexity got chosen to be supported. This option was made in order to illustrate important language implementation concepts, such as optimized code generation and type-checking at compile-time. 
        \item \textbf{Formally Specified:} In order to make a robust tie between the theoretical concepts presented in undergraduate Compilers courses and  their applications in an implementation project, the authors opted for a language whose syntax, type-checking rules and operational semantics were all formally specified. With these needs kept in mind, Python was a good alternative and, hence, was chosen.
        \item \textbf{Modern Target Language:} Instead of targeting an old or too complex Assembly language, the authors opted to make the code generation phase less intimidating, by instead opting to target the 32-bits RISC-V Instruction Set Architecture \cite{riscv_instruction_set_manual}, which is more modern and simpler.
        \item \textbf{Re-usability:} One of the major reasons for ChocoPy's creation was the democratization of artifacts that could be freely used by professors, instructors, teaching assistants and students from different institutions offering Compilers courses.
    \end{itemize}

    The language started out being used at the UC Berkeley, as stated in \cite{padhye2019chocopy}, and since then has been adopted by several other institutions, such as: TU Delft \cite{tu_delft_cs4200_2020_compiler_construction_course_page}, UC San Diego \cite{uc_san_diego_cse213_winter2021_advanced_compiler_design_course_page} and NYU \cite{nyu_2020_compiler_construction_course_page}. Finally, the ChocoPy language specification was also used as a reference at IIT Bombay \cite{iit_bombay_sclp}.

    As previously stated, ChocoPy was designed to be a subset of Python. In practice, this means that every valid ChocoPy program that does not result in a runtime error is also a valid Python program. Therefore, the result observed when executing the said ChocoPy program is equal to the one when executing the same program in a Python Interpreter. When it comes down to language features, ChocoPy has support for statements, expressions, assignments and control-flow structures (conditionals and loops). When dealing with evaluation of an expression, the result will always have one of the following types: a boolean, an integer, a list, a string, an user-defined class or the special value \texttt{None}. Unfortunately, according to the authors of \cite{padhye2019chocopy}, the language does not have support for the \texttt{dict} type, first-class functions and reflective introspection. It is also worth mentioning that every expression in ChocoPy is statically typed. On top of it, variables (both global and local ones) and class attributes are also statically typed and have explicit type annotations. Ultimately, type annotations are also present in function and method declarations in order to signal the parameters' and return value's type. More information about ChocoPy's features can be found in \cite{padhye2019chocopy} and in \cite{chocopy_v2.2_language_manual_reference}.
    
\end{itemize}

\section{Revisiting Bleach's Purpose}
As stated in the summary and previous sections of this thesis, Bleach is a programming language intended to be used as a tool by teachers, instructors and teaching assistants responsible for undergraduate Compilers courses, ubiquitous in Bachelor's degrees in Computer Science and Computer Engineering.

The inspiration to create Bleach came from the fact that even though there are new approaches that combine theory and practice to expose the contents of the course's syllabus, there are still worrying issues when it comes down to the learning experience of the students, as reported by Lasseter in \cite{lasseter2015interpreter}. With regards to this particular issue raised, the approach proposed by Nystrom in \cite{nystrom2021crafting} seems to be a good and innovative way of teaching Compilers. To reinforce the benefits of a more practical line of action, it's worth remembering that, as seen in the previous section, the "Case-based and Project-based" approach proposed by Kundra et al. in \cite{kundra2016experience} ratifies the idea that a project-based direction for the course is, indeed, a good option when prioritizing the students' experience. On the other hand, such a approach must be executed with carefulness since a similar approach proposed by Aho in \cite{aho2008teaching} may be unfeasible, especially in scenarios where there is a lack of teaching assistants or classes with too many students.

Keeping all of these mentioned points in mind, Bleach aims to be an alternative programming language that seeks to be used in undergraduate Compilers courses as a mean to engage and motivate students during the learning process of this subject, while also providing enough theoretical foundation for the students in this matter. In addition, it also relieves professors, instructors and teaching assistants from the burden of dealing with dozens of programming languages created by class students.

\section{Scenario Overview}
In this section, the context in which Bleach is expected to be used, who will be using it, and how it fits into the educational environment of undergraduate Compilers courses are all presented with more details.

\begin{itemize}
    \item \textbf{Target Audience:} Bleach's target audience is divided into two different, but related groups: The first one is composed of undergraduate students that are enrolled in Compilers courses, which are part of Computer Engineering and Computer Science programs. These students are expected to have fundamental knowledge about programming languages, algorithms, data structures, but lack the more foundational understanding needed to implement compilers or interpreters. The second one is composed of professors, instructors and teaching assistants who are interested in providing a more incremental and hands-on experience to their students when it comes to compilers and interpreters design.
    
    \item \textbf{Use Cases and Educational Benefits:} Bleach was designed for use within undergraduate Compilers courses. The language is intended to be used as a practice tool, so students can apply the learned core compiler concepts during the classes in order to construct a programming language implementation that resembles those widely used by them, such as C, Python and JavaScript, for example. Through the use of Bleach, students can incrementally build an interpreter or compiler for the Bleach language by completing assignments that involve the implementation or extension of a lexer, a parser, a static analyzer, a IR generator, an optimizer, a code generator and, finally, a virtual machine or runtime. In short, this methodology is expected to provide enough practical experience in this course for the students.
    
\end{itemize}