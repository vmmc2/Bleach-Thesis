\chapter{Context and Purpose} \label{cap:metodologia}

\begin{displayquote}
    \begin{center}
        \textit{``I wonder if I can keep up with... the speed of a world you're not in.''}
    \end{center}
\end{displayquote}

\begin{flushright}
   \textit{-- TITE KUBO}
\end{flushright}

\section{Introduction}
This chapter is dedicated to provide the historical context behind how the way of teaching undergraduate Compilers courses evolved since the 70s, as well as a brief overview of surveys that demonstrate the positive impact that more practice-orient approach brings to students. Such factors are what motivated the creation of the Bleach programming language. Furthermore, a revisit and deepening regarding the purpose of Bleach will also be made. Then, an analysis about how Bleach distinguishes itself from other proposed programming languages that also aim to solve its same issue will be presented. In the end, the chapter will provide a detailed description about the context Bleach is inserted in, which includes: the target audience, educational environment, typical use cases and the educational benefits provided by it.

\section{Historical Context of Undergraduate Compilers \newline Courses}
Looking back, it can be said that the way of teaching an undergraduate Compilers course evolved as follows:

During the 1970s, undergraduate Compilers courses used to have a heavy focus on the theoretical aspects of the field, such as: formal languages, automata theory, lexing techniques and parsing techniques. During that period, access to computational resources were still scarce, even in an academic environment. However, students were still able implement toy compilers in different tastes of Assembly or in an early high-level language like Fortran \cite{fortran_official_website}. Still, the pillars of this course emphasized a deep understanding of the theoretical and formal aspects mentioned above.

In the 1980s, even though the focus of these courses remained rooted in theoretical aspects (lexical analysis, syntax analysis and the fundamental of code generation and optimization), a gradual shift from theory to practice started to happen. Thanks to the spread of languages like C \cite{kernighan1988c}, C++ \cite{strousrup2000c++} and Pascal \cite{wirth1971programming}, more practical implementations of compilers were allowed to be made. Therefore, courses started to add more practical projects. In such projects, students were usually asked to write a compiler (or parts of one) in these new languages. Last, but not least, the rise of UNIX \cite{ritchie1978unix}, Lex \cite{lesk1975lex} and Yacc \cite{johnson1975yacc} allowed students to implement components of a compiler with more ease. This improvement led to more sophisticated course projects.

In the 90s, such courses had already become more oriented to hands-on experience thanks to the improvements achieved in the previous decade. The birth of languages like Java \cite{java_17_official_specification} and the increase in computational power of personal computers allowed students to tackle more complex compiler projects. Courses started to assign to students more complicated tasks like the implementation of entire compilers for small languages or significant compiler components, such as code generators and optimizers. Moreover, the textbook \cite{aho1986compilers}, popularly known as "The Dragon Book", became the standard reference in this field.

In the 00s, this trend of giving more focus to the practical experience went on, with a focus on real-world applications and the use of modern programming languages. Furthermore, courses began to add more advanced topics to their syllabus, such as just-in-time compilation, garbage collection, and runtime environments. It's safe to say that the way of teaching Compilers became more holistic, covering not just compiler theory and implementation but also language design and performance optimization. During this period, Alfred Aho published \cite{aho2008teaching}, an article in which he reflects on how the way of teaching undergraduate Compilers courses has evolved through the years and also how he changed his way of teaching such course. According to him, it is still possible to teach it in a way that provides educational benefits and satisfaction to the students. The latest approach adopted by him consisted on presenting the basics of the most important topics (lexical analysis, parsing, semantic analysis, intermediate code generation, runtime environments, resource management and target code generation). At the same time, Aho asked his students to implement a compiler and provided the specifications of the source and target languages for the compiler they were implementing. He also noticed that the students weren't excited about implementing someone else's language. Thus, he took a bold move and assigned his students the task of working in smalls team to define their own
language and then build a compiler for it. Such approach, according to him, made the students much more engaged and excited.

Finally, in the 2010s and 2020s, the teaching of this course continued the trend of emphasis on balancing theory and practice. Such factor influenced the way Compilers course were taught, as professors and instructors began to integrate more diverse and flexible learning materials, including video lectures, interactive simulations, and online coding platforms. Also, the COVID-19 pandemic played an important role in this change, since it forced educators to rethink how compilers could be taught in a remote manner, which led to rise of new assisting tool like virtual laboratories, collaborative coding environments and online assessment tools. Consequently, such courses became more modular, allowing students to learn at their own pace and apply their knowledge in a way that felt meaningful to them.

\section{Reports on More Practical Ways of Teaching Compilers Courses}
In this section, a few reports that discuss different approach to teach an undergraduate Compilers course are presented, along with their main findings.

In 2015, Lasseter \cite{lasseter2015interpreter} proposed a new strategy to present the fundamental concepts of an undergraduate Compiler Construction course. The suggested approach defends that the concept of an Interpreter serves as an effective conceptual framework that can be used to educate students about the later stages of the compilation pipeline, specially the semantic analysis and code generation phases. As reported by the author, this line of action is useful in the way that it not only unifies the major theoretical concepts of this undergraduate course, but is also helpful when it comes to the implementation of semester-long compiler construction project. At Hobart \& William Smith Colleges, the university where Lasseter works, the undergraduate Compiler Construction course is a one-semester, upper-division elective, offered every other year. The course addresses both software engineering aspects as well as the major concepts of a traditional Compilers course (lexing, parsing, semantic analysis and code generation). Moreover, it already adopts a more practice-oriented approach where every student must present a working compiler by the end of the 15-week semester. When it comes to the course project itself, Lasseter opted to use the Tiger programming language \cite{appel1998tiger}, originally developed by Andrew Appel for his project-oriented "Modern Compiler Implementation" suite of C, ML and Java textbooks \cite{appel1997modernCompilerImplementationC}, \cite{appel2002modernCompilerImplementationJava}, \cite{appel2004modernCompilerImplementationML}. During the years in which the author was responsible for this course, he noticed a worrying pattern: Even though the students did well in the first stages of compilation (lexing and parsing), the vast majority of them started to struggle with the semantic analysis stage. According to the students, the combination of the underlying concepts of type checking, the details of the famous visitor pattern when traversing an AST and the interaction between this design pattern and a real-world semantic analysis implementation is just too overwhelming. Given this scenario, Lasseter chose to schedule individual meetings with this students where he introduced the idea of a language's interpreter as a touchstone to better explain the last two stages of the compilation pipeline. His investigation led to the fact that such approach proved to be the to be most uniformly effective among the students with whom he discussed. In light of this discovery, professor Lasseter reorganized his lectures introducing these specific compiler phases to include the interpreter structure as a reference point. Finally, he came to the conclusion that adding lectures that presented the concepts behind the interpreter framework resulted on better understanding of the students when it came down to the semantic analysis and code generation phases of the compilation process, indicating that the idea of an interpreter has a substantial educational value in this field.

In 2016, Kundra et al. \cite{kundra2016experience} proposed a novel approach called "Case-based and Project-based Learning" to teach a Compilers Design course to B.Tech third year students of a Delhi University (India) college. The responsibles for implementing such methodology based themselves in the definition of what is Traditional Learning present in \cite{altman2010workplace} and used the definition and core ideas of Case-based Learning present in \cite{golich2000abcs} in order to propose their own method. According to the authors, this proposed method combines 4 different pedagogical models, which makes this approach unique and effective: Didactic Teaching \cite{altman2010workplace}, Problem-Based Learning \cite{hmelo2004problem}, Cognitive Apprenticeship Model \cite{dennen2008cognitive} and Project-Based Learning \cite{thomas2000review}. To implement it, they divided one core project of this class into several sub-projects with the goal of improving the practical experience of the students when it came down to the task of designing a compiler. To evaluate the effectiveness of this approach, students were asked to complete a survey that grasped on their perceptions about the upsides of such method. Such survey was analyzed using the following statistical tools: frequency estimation and chi square test of association. According to the paper, the results showed that the proposed approach indeed had a positive impact on students since it enhanced their learning, critical thinking, engagement, communication skills and team work. In the end, the authors came to the conclusion that the outcome of the survey analysis proved that both Case-based and Project-based learning are suitable for teaching concepts of compilers implementation.

In 2021, Robert Nystrom, a software engineer that works at Google on the Dart language, published the "Crafting Interpreters" book \cite{nystrom2021crafting}: An extensive guide about not only implementing two different types of interpreters for Lox, a full-featured programming language designed by the author, but also a walkthrough that guides the readers on how they can design their own programming language. The book assumes that its the reader first contact with this field. Therefore, it covers each concept needed in an approachable style while also providing every line of code needed to implement the two types of interpreters covered. As the author himself admits in the first chapter of the book, "Crafting Interpreters" is not meant to be as rigorous as other references, such as \cite{aho1986compilers} or \cite{cooper2022engineering} when it comes to the theoretical foundation of programming languages. Instead, as suggested earlier, its purpose is to be lighter in theory, while still introducing the history and core concepts of programming languages implementation. Moreover, the author stands by the point of view that the best way of learning a new subject is by practicing and experimenting. He even says that his goal is that every reader finish his book with a solid intuition about how real programming languages work. The book also aims that the reader will feel more comfortable when reading more advanced and theoretical books later on, such as \cite{aho1986compilers}, \cite{cooper2022engineering} or \cite{muchnick1997advanced}. It's important to keep in mind that the book's focus is on building interpreters, which are simpler and more accessible to understand when compared to compilers. Furthermore, this way of teaching allows the students to have a better comprehension of vital concepts previously mentioned, like lexing/scanning, parsing, abstract syntax trees, semantic analysis and runtime execution without the daunting complexity of optimization and code generation phases that most compilers require. This approach brings a lot of benefits for students and professors. With respect to the students, they are usually able to build a deeper and stronger foundation about how programming languages work since the project-based nature of the book makes them apply what they learn immediately. This solid foundation is, without a doubt, of great use to those who wish to delve deeper into the field. As for the professors, the engaging writing style of the book tends to keep students engaged and motivated during the whole duration of the course, which leads to a better retention and a more rewarding learning experience. Last but not least, it's important to highlight the fact that the "Crafting Interpreters" book is increasingly gaining more popularity and recognition due to its excellence when it comes to conveys the subject of study. It's purchase page on Amazon \cite{nystrom_crafting_interpreters_amazon} is full of reviews praising its quality. Searching for the keywords "crafting interpreters" \cite{crafting_interpreters_repositories_github} shows that there are more than 2600 public repositories implementing the Lox language presented in the book, which is also a testimonial of the popularity and quality of such material.

\section{Revisiting Bleach's Purpose}
As stated in the summary and previous sections of this document, Bleach is a programming language intended to be used as a tool by teachers, instructors and teaching assistants responsible for undergraduate courses in Compilers, ubiquitous in Bachelor's degrees in Computer Science and Computer Engineering.

The inspiration to create Bleach came from the fact that even though there are new approaches that combines theory and practice to expose the contents of the course's syllabus, there are still worrying issues when it comes down to the learning experience of the students, as reported by Lasseter in \cite{lasseter2015interpreter}. With regards to this particular issue raised, the approach proposed by Nystrom in \cite{nystrom2021crafting} seems to be a good and innovative way of teaching Compilers. To reinforce the benefits of a more practical line of action, it's worth remembering that, as seen in the previous section, the "Case-based and Project-based" approach proposed by Kundra et al. in \cite{kundra2016experience} ratifies the idea that a project-based direction for the course is, indeed, a good option when prioritizing the students' experience. On the other hand, such a approach must be executed with carefulness since a similar approach proposed by Aho in \cite{aho2008teaching} may be unfeasible, especially in scenarios where there is a lack of teaching assistants or classes with too many students.

Keeping all of these mentioned points in mind, Bleach aims to be an alternative programming language that seeks to be used in undergraduate Compilers course as a means to engage and motivate students during the learning process of this subject, while also providing enough theoretical foundation for the students in this matter. In addition, it also relieves professors, instructors and teaching assistants from the burden of dealing with dozens of programming languages created by class students.

\section{Existing Toy Programming Languages}

Before taking a deep dive in what makes Bleach an actual and viable option to be used in a classroom environment, it's important to mention that there are several programming languages created with the purpose of being a supplementary tool for teaching undergraduate Compilers course that have opted for a more practice-oriented procedure.

In this section, some of the most popular programming languages designed with this motivation will be discussed in chronological order. The intention with this is to provide information about their origin, historical context and features.

\begin{itemize}
    \item \textbf{COOL (Classroom Object-Oriented Language):} This is a object-oriented and statically-typed programming language \cite{aiken1996cool} created in the 90s by Alexander Aiken and his colleagues at the Stanford University. It was designed with the intention to be used as a tool in an educational setting in universities. Even though COOL is simple and small, it has an interesting variety of features besides the ones mentioned above, such as: basic class types (Bool, Int, IO, Object and String), automatic garbage collection and many others that can be found at "The COOL Reference Manual" \cite{cool_reference_manual}.
    
    According to Aiken, a compiler project is normally the most complex software project that most undergraduate students will complete. Therefore, the use of a full-featured programming language (any language that has a substantial number of users, like C, C++, Pascal, etc) does not fit into the scope of such project. In practice, the usual approach was to select a subset of these popular languages and ask the students to implement them. However, according to Aiken, this method is too demanding for the teaching staff, since several steps must be taken after choosing a language for a Compilers project. For example: a detailed specification of the project itself must be written, any supporting software that might be used must be developed, tested and documented beforehand. Finally, the project itself must also be implemented by the teaching staff \textit{a priori} since, according to Aiken, such effort is required to guarantee that the project is complete, consistent and tractable.
    
    It was with all the efforts mentioned above to build a framework for a compiler project  in mind that Aiken created COOL. Ultimately, it is worth mentioning that COOL is not only a programming language, but rather a freely available and portable compiler project. COOL has being distributed since its creation with the goal of helping professors from other institutions to leverage from the efforts of the project developers and the many students who have written COOL compilers in order to structure their own Compilers courses following their own tastes. COOL has been adopted at several relevant institutions, such as University of California, Berkeley \cite{aiken1996cool} (where it was first introduced), Stanford University \cite{stanford_cs143_compilers_course_page}, University of Illinois Urbana-Champaign \cite{university_of_illinois_urbana_champaign_compilers_course_page} and University of Michigan \cite{university_of_michigan_compiler_construction_course_page}.
    
    \item \textbf{MiniJava:} This programming language \cite{cambridge_minijava_project} is a subset, as its name suggests, of the Java programming language. MiniJava was created by Andrew Appel and Jens Palsberg during the 90s and was first presented as part of \cite{appel2002modernCompilerImplementationJava}. This subset of Java contains its most core features, such as: classes, attributes/fields, methods, logical control structures (if-else) and loop control structures (while). However, since it was tailored for an educational environment, it doesn't contain Java's more advanced features, like: exceptions, generics, inheritance, interfaces and lambda functions. More details about which features MiniJava exactly keeps can be found at \cite{cambridge_minijava_project} and \cite{cambridge_minijava_grammar}.
        
    Its purpose is to be used as a teaching tool in Compilers courses. Since it is a subset, as previously mentioned, it allows the students to focus on the fundamental concepts of this subject without overwhelming them with the complexities of a full-fledged programming language like Java.
    A proof of its success is that MiniJava has been adopted in several prestigious universities worldwide as part of their computer science curriculum, particularly in courses related to compiler construction and programming language implementation, such as University of Washington \cite{university_of_washington_cs_compiler_construction_course_page_2024}, University of California, Los Angeles \cite{ucla_cs_compiler_construction_course_page_fall_2012}, among others, like the Loyola University of Chicago \cite{loyola_university_of_chicago_cs_compiler_construction_course_page_fall_2018}.     
    
    \item \textbf{Selfie:}
    \begin{itemize}
        \item \textbf{Context/Origin:} The Selfie programming language \cite{kirsch2017selfie} is a programming language created in 2017 
        \item \textbf{Purpose:}
        \item \textbf{Adoption:}
        \item \textbf{Core Features:}
    \end{itemize}
    
    \item \textbf{Chocopy:}
    \begin{itemize}
        \item \textbf{What is:} ChocoPy is a programming language created in 2019 and first presented at Padhye et al. \cite{padhye2019chocopy} with the goal of being used as a teaching tool in an undergraduate course on compilers and programming language. It is a subset of Python 3.6 that uses static type annotations in order to ensure compile-time type-safety. 
        The project stands out due to its complete specification, which uses a formal grammar, typing rules and operational semantics as described in \cite{padhye2019chocopy}.
        \item \textbf{Purpose:}
        \item \textbf{Adoption:} The language started out being used at the UC Berkeley and since then has been adopted by several other institutions, such as: TU Delft \cite{}, UC San Diego{} and NYU \cite{}. 
        \item \textbf{Core Features:}
    \end{itemize}
    
\end{itemize}

-> Falar sobre a abordagem incremental, flexível e modular de Bleach. Como ela é mais abrangente que MiniJava. E como ela é mais educativa, flexível e modular do que Cool, Chocopy e Selfie.

\section{Scenario Overview}
